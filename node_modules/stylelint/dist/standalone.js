"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var files = _ref.files;
  var code = _ref.code;
  var codeFilename = _ref.codeFilename;
  var config = _ref.config;
  var configFile = _ref.configFile;
  var configBasedir = _ref.configBasedir;
  var configOverrides = _ref.configOverrides;
  var ignoreDisables = _ref.ignoreDisables;
  var ignorePath = _ref.ignorePath;
  var reportNeedlessDisables = _ref.reportNeedlessDisables;
  var _ref$formatter = _ref.formatter;
  var formatter = _ref$formatter === undefined ? "json" : _ref$formatter;
  var syntax = _ref.syntax;

  var isValidCode = typeof code === "string";
  if (!files && !isValidCode || files && (code || isValidCode)) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both");
  }

  var chosenFormatter = typeof formatter === "string" ? formatters[formatter] : formatter;

  if (!chosenFormatter) {
    return Promise.reject(new Error("You must use a valid formatter option, either: json, string or verbose"));
  }

  var stylelint = (0, _createStylelint2.default)({
    config: config,
    configFile: configFile,
    configBasedir: configBasedir,
    configOverrides: configOverrides,
    ignoreDisables: ignoreDisables,
    ignorePath: ignorePath,
    reportNeedlessDisables: reportNeedlessDisables,
    syntax: syntax
  });

  if (!files) {
    return stylelint._lintSource({ code: code, codeFilename: codeFilename }).then(function (postcssResult) {
      return stylelint._createStylelintResult(postcssResult);
    }).catch(handleError).then(function (stylelintResult) {
      return prepareReturnValue([stylelintResult]);
    });
  }

  return (0, _globby2.default)([].concat(files, alwaysIgnoredGlobs)).then(function (filePaths) {
    if (!filePaths.length) {
      var err = new Error("Files glob patterns specified did not match any files");
      err.code = 80;
      throw err;
    }

    var getStylelintResults = filePaths.map(function (filePath) {
      return stylelint._lintSource({ filePath: filePath }).then(function (postcssResult) {
        return stylelint._createStylelintResult(postcssResult, filePath);
      }).catch(handleError);
    });

    return Promise.all(getStylelintResults);
  }).then(prepareReturnValue);

  function prepareReturnValue(stylelintResults) {
    var errored = stylelintResults.some(function (result) {
      return result.errored;
    });
    var returnValue = {
      errored: errored,
      output: chosenFormatter(stylelintResults),
      results: stylelintResults
    };
    if (reportNeedlessDisables) {
      returnValue.needlessDisables = (0, _needlessDisables2.default)(stylelintResults);
    }
    return returnValue;
  }
};

var _formatters = require("./formatters");

var formatters = _interopRequireWildcard(_formatters);

var _flowDeclarations = require("./flow-declarations");

var _cssSyntaxError = require("postcss/lib/css-syntax-error");

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _createStylelint = require("./createStylelint");

var _createStylelint2 = _interopRequireDefault(_createStylelint);

var _globby = require("globby");

var _globby2 = _interopRequireDefault(_globby);

var _needlessDisables = require("./needlessDisables");

var _needlessDisables2 = _interopRequireDefault(_needlessDisables);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var alwaysIgnoredGlobs = ["!**/node_modules/**", "!**/bower_components/**"];

function handleError(error) {
  if (error.name === "CssSyntaxError") {
    return convertCssSyntaxErrorToResult(error);
  } else {
    throw error;
  }
}

// By converting syntax errors to stylelint results,
// we can control their appearance in the formatted output
// and other tools like editor plugins can decide how to
// present them, as well
function convertCssSyntaxErrorToResult(error) {
  if (error.name !== "CssSyntaxError") {
    throw error;
  }

  return {
    source: error.file || "<input css 1>",
    deprecations: [],
    invalidOptionWarnings: [],
    errored: true,
    warnings: [{
      line: error.line,
      column: error.column,
      rule: error.name,
      severity: "error",
      text: error.reason + " (" + error.name + ")"
    }]
  };
}